#!/bin/bash
#

# Here are variables initiated by load_and_run script:
#
#  - PART_NAME
#  - PART_DIR
#
# Here are variables initiated by apply_parts command,
# stored in ${WORK_DIR}/env.bash
# 
#  - CLI_DIR
#  - ELINUX_TOOLS_DIR
#
#  (Following variables are retrieved from ${ARCHIVE_DIR}/rootfs.yaml)
#  - BOARD_DIST_CODENAME   bone, raspbian, ...
#  - DIST_CODENAME         trusty, jessie, ...
#  - DIST_NAME             ubuntu, debian, ...
#  - KERNEL_ARCHITECTURE   armv7l
#  - KERNEL                linux
#  - KERNEL_VERSION        4.1.17-ti-rt-r47
#
#  (Following variables are retrieved from the config.json passed to apply_parts subcommand, all are optional)
#  - BOARD_NAME            bbgw, bbg, piz, pizw, ...
#  - BOARD_ENV             production, testing, development, ...
#  - BOARD_PROFILE         abc, def, spider, ...
#
#  (Following variables are derived from parent process `emb_apply_parts`)
#  - AD_BUILD_CONF_JSON       = /tmp/xxx.json
#  - AD_BUILD_WORK_ENV_BASH   = /tmp/xxx-20170413223843/partitions/p2/work/apply_parts_20170413223843/env.bash
#  - AD_BUILD_WORK_ENV_JSON   = /tmp/xxx-20170413223843/partitions/p2/work/apply_parts_20170413223843/env.json
#  - AD_BUILD_WORK_PARTS_DIR  = /tmp/xxx-20170413223843/partitions/p2/work/apply_parts_20170413223843/parts
#  - AD_BUILD_WORK_PARTS_FILE = /tmp/xxx-20170413223843/partitions/p2/work/apply_parts_20170413223843/parts.txt
#
#  - AD_BUILD_WORK_DEBIAN_PKG_LIST  = /tmp/xxx-20170413223843/partitions/p2/work/apply_parts_20170413223843/package-debian.txt
#  - AD_BUILD_WORK_PYTHON2_PKG_LIST = /tmp/xxx-20170413223843/partitions/p2/work/apply_parts_20170413223843/package-python2.txt
#  - AD_BUILD_WORK_PYTHON3_PKG_LIST = /tmp/xxx-20170413223843/partitions/p2/work/apply_parts_20170413223843/package-python3.txt
#  
#  - AD_BUILD_WORK_TOPDIR    = /tmp/xxx-20170413223843/partitions/p2/work/apply_parts_20170413223843
#
#  - AD_TOPDIR               = /tmp/xxx-20170413223843
#  - AD_CONF_JSON            = /tmp/xxx-20170413223843/config.json
#  - AD_PARTITION_DIR        = /tmp/xxx-20170413223843/partitions
#  - AD_ROOTFS_DIR           = /tmp/xxx-20170413223843/partitions/p2
#  - AD_ROOTFS_METADATA_FILE = /tmp/xxx-20170413223843/rootfs.yaml
#  - AD_ROOTFS_PARTITION     = p2
#  - AD_ROOTFS_TYPE          = bone
# 


function repartition_archive_directory {
	local AD_CONF_JSON_BAK=$(mktemp /tmp/XXXXXX)
	local OLD_UUID=$(cat ${AD_CONF_JSON} | jq ".partitions.p2.uuid" | sed 's/\"//g')
	cp ${AD_CONF_JSON} ${AD_CONF_JSON_BAK}
	cat ${AD_CONF_JSON_BAK} \
		| jq ".partitions.p1.p_end = \"${TOE2_BASE_P1_END}%\""	\
		| jq ".partitions.p2.p_start = \"$((TOE2_BASE_P1_END+1))%\""	\
		| jq ".partitions.p2.p_end = \"${TOE2_BASE_P2_END}%\""	\
		| jq ".partitions.p2.uuid = \"${TOE2_BASE_P2_UUID}\""	\
		| jq ".partitions.p3 = {}"	\
		| jq ".partitions.p3.type = \"ext4\""	\
		| jq ".partitions.p3.label = \"app\""   \
		| jq ".partitions.p3.uuid = \"${TOE2_BASE_P3_UUID}\""	\
		| jq ".partitions.p3.p_start = \"$((TOE2_BASE_P2_END+1))%\""	\
		| jq ".partitions.p3.p_end = \"${TOE2_BASE_P3_END}%\""	\
		| jq ".partitions.p4 = {}"	\
		| jq ".partitions.p4.type = \"ext4\""	\
		| jq ".partitions.p4.label = \"data\""	\
		| jq ".partitions.p4.uuid = \"${TOE2_BASE_P4_UUID}\""	\
		| jq ".partitions.p4.p_start = \"$((TOE2_BASE_P3_END+1))%\""	\
		| jq ".partitions.p4.p_end = \"100%\""	\
		> ${AD_CONF_JSON}
	INFO "after repartitioning to layout-03:"
	cat ${AD_CONF_JSON} | jq .partitions | awk '{printf "\t%s\n", $0}'
	rm -f ${AD_CONF_JSON_BAK}
	rm -f ${AD_TOPDIR}/config.ls

	case "${BOARD_DIST_CODENAME}" in
		bone)
			sed -i "s/${OLD_UUID}/${TOE2_BASE_P2_UUID}/g" ${AD_PARTITION_DIR}/p1/uEnv.txt
			INFO "update uEnv.txt to use new uuid $(PURPLE ${TOE2_BASE_P2_UUID}):"
			cat ${AD_PARTITION_DIR}/p1/uEnv.txt | awk '{printf "\t%s\n", $0}'
			;;
		*)
			ERR "unsupport BOARD_DIST_CODENAME(${BOARD_DIST_CODENAME}) to modify rootfs' uuid for bootloader"
			return 2
			;;
	esac
	return 0
}


function generate_file_for_build_information {
cat <<__EOF__
# 
# Built-At: $(date '+%Y/%m/%d %H:%M')
# Built-By: $(whoami)
# Built-With: $(PART_NAME)
#
BOARD: ${BOARD_NAME}
BOARD_PROFILE: ${BOARD_PROFILE}
BOARD_ENV: ${BOARD_ENV}

##
## (Deprecated)
##
## BOARD_TIMEZONE: ${BOARD_TIMEZONE}
__EOF__
}


function generate_file_for_ys_conf {
cat << __EOF__
OS_PARTITION_SYS_ID	${TOE2_BASE_PARTITION_ID_ROOTFS}
OS_PARTITION_APP_ID	${TOE2_BASE_PARTITION_ID_APP}
OS_PARTITION_DAT_ID	${TOE2_BASE_PARTITION_ID_DATA}
OS_NAME	${KERNEL}-${DIST_NAME}-${DIST_CODENAME}
OS_ARCH	${KERNEL_ARCHITECTURE}
OS_IMAGE	${BOARD_IMAGE_URL}
OS_SCRIPT_REV	${BOARD_IMAGE_SCRIPT_REVISION}
BOARD	${BOARD_NAME}
PROFILE	${BOARD_PROFILE}
ENV	${BOARD_ENV}
YS_DIR	${TOE2_BASE_YAPPS_SCRIPTS_DATA_DIR}

##
## (Deprecated)
##
## YS_APTKEYS_DIR	${BOARD_YS_APTKEYS_DIR}
__EOF__
}


function generate_file_for_profile_conf {
echo "PROFILE = ${BOARD_PROFILE}"
}


function read_part_variable {
	local NAME=$1
	local PART_UPPERCASE_NAME=$(echo ${PART_NAME} | tr '[a-z]' '[A-Z]' | tr '-' '_')
	local VARIABLE_NAME="${PART_UPPERCASE_NAME}_${NAME}"
	echo ${!VARIABLE_NAME}
}


function compose_file {
	local FUNC_NAME=$1
	local FILE_NAME=$2
	[ "" == "${FUNC_NAME}" ] && ERR "missing FUNC_NAME" && return 1
	[ "" == "${FILE_NAME}" ] && ERR "missing FILE_NAME" && return 2
	local FILE_PATH=$(read_part_variable ${FILE_NAME})
	[ "" == "${FILE_PATH}" ] && ERR "missing FILE_PATH" && return 3
	local FILE_FULLPATH="${AD_ROOTFS_DIR}${FILE_PATH}"
	mkdir -p $(dirname ${FILE_FULLPATH}) || return 4
	generate_file_for_${FUNC_NAME} > ${FILE_FULLPATH} || return 5
	INFO "$(PURPLE ${FUNC_NAME}) ($(GRAY ${FILE_PATH}))" && cat ${FILE_FULLPATH} | awk '{printf "\t%s\n", $0}'
}


function update_git_dir {
	local VAR_NAME=$1
	[ "" == "${VAR_NAME}" ] && ERR "missing VAR_NAME" && return 1
	local DST_PATH=$(read_part_variable ${VAR_NAME})
	[ "" == "${DST_PATH}" ] && ERR "missing DST_PATH" && return 2
	local DST_FULLPATH="${AD_ROOTFS_DIR}${DST_PATH}"
	[ ! -d "${DST_FULLPATH}" ]      && ERR "missing directory ${DST_FULLPATH} to update git" && return 3
	[ ! -d "${DST_FULLPATH}/.git" ] && ERR "missing directory ${DST_FULLPATH}/.git to update git" && return 4
	local TMP_DIR=$(pwd)
	cd ${DST_FULLPATH}
	git pull || return 3
	cd ${TMP_DIR}
	return 0
}


function show_rootfs_file {
	INFO "$(PURPLE $1) ($(GRAY ${AD_ROOTFS_DIR}$1))"
	cat ${AD_ROOTFS_DIR}$1 | awk '{printf "\t%s\n", $0}'
}


function update_hostname {
	local DST_FILE="${AD_ROOTFS_DIR}/etc/hostname"
	run_my_cmd "echo ${DEFAULT_HOSTNAME} > ${DST_FILE}"
	show_rootfs_file /etc/hostname
}


function update_hosts {
	local DST_FILE="${AD_ROOTFS_DIR}/etc/hosts"
	run_my_cmd "sed -i \"s/^127.0.1.1.*/127.0.1.1\t${DEFAULT_HOSTNAME} ${DEFAULT_HOSTNAME}.localdomain/g\" ${DST_FILE}"
	show_rootfs_file /etc/hosts
}


function attach_to_init_process {
	local DST_FILE="${AD_ROOTFS_DIR}/etc/rc.local"
	run_my_cmd "sed -i \"s/^exit.*//g\" ${DST_FILE}"
	echo '[ -f "${BASH_SOURCE[0]}" ] && $BASH ${BASH_SOURCE[0]}' >> ${DST_FILE}
	echo 'exit 0' >> ${DST_FILE}
	show_rootfs_file /etc/rc.local
}


function append_path_variable {
	local DST_FILE="${AD_ROOTFS_DIR}/etc/environment"
	local TMP_FILE=$(mktemp /tmp/XXXXXX)
	echo "/opt/yapps-scripts/bin" >> ${TMP_FILE}
	cat ${DST_FILE} | grep "^PATH" | awk -F'=' '{print $2}' | sed 's/\"//g' | tr ':' '\n' >> ${TMP_FILE}
	sed -i 's/^PATH\=.*//g' ${DST_FILE}
	local P=$(cat ${TMP_FILE} | tr '\n' ':' | sed 's/\:$//g')
	echo "PATH=\"${P}\"" >> ${DST_FILE}
	rm -f ${TMP_FILE}
	INFO "PATH = $(GREEN ${P})"
	show_rootfs_file /etc/environment
}


function append_etc_environment {
	local DST_FILE="${AD_ROOTFS_DIR}/etc/environment"
cat << __EOF__ >> ${DST_FILE}
YS_DIR=${TOE2_BASE_YAPPS_SCRIPTS_DATA_DIR}
YAC_DIR=${TOE2_BASE_YAPPS_SCRIPTS_SRC_DIR}
BOARD=${BOARD_NAME}
BOARD_PROFILE=${BOARD_PROFILE}
USE_NODE_VERSION_CACHE=true
BASHRC_EXTRA=${TOE2_BASE_YAPPS_SCRIPTS_SRC_DIR}/.bashrc
__EOF__
	show_rootfs_file /etc/environment
}


function update_dotfiles {
	update_git_dir YAGAMY_DOTFILES_DIR
}


# Before archive directory is manipulated.
#
function pre_image {
	repartition_archive_directory || return 1
}


# After copying files to root-fs and partition directories.
#	- elinux-common/copy_partitions      , rsync `${PART}/partitions/p[0-9]/*` to `${AD_PARTITION_DIR}/p[0-9]`
#	- elinux-common/copy_rootfs          , rsync `${PART}/rootfs/*` to `${AD_PARTITION_DIR}/${AD_ROOTFS_PARTITION}`
#	- elinux-common/copy_service_files
#	    for s of services
#	        find ${PART_DIR}/assets/services/${s}/*
#	        copy them to ${AD_BUILD_WORK_TOPDIR}/elinux-common/services/${s}
#	        maybe in the future, implement copy-with-template
#
# Before running script inside rootfs with chroot and qemu (guest script).
#
function pre_guest {
	export DEFAULT_HOSTNAME="r0"
	compose_file "build_information"  YAPPS_DATA_FILE_BUILD_INFO || return 1
	compose_file "ys_conf"            YAPPS_SCRIPTS_CONF || return 1
	compose_file "profile_conf"       YAPPS_PROFILE_CONF || return 1
	attach_to_init_process || return 1
	append_path_variable || return 1
	append_etc_environment || return 1
	update_hostname || return 1
	update_hosts || return 1
	update_dotfiles || return 1
	return 0
}


# After running script inside rootfs with chroot and qemu
# Before cleanup temporary/cache files in archive directory
#
function post_guest {
	return 0
}


# After cleanup temporary/cache files in archive directory
#
function post_image {
	return 0
}

